name: ğŸš€ Build and Release SunoReady

on:
  push:
    tags:
      - 'v*'  # Trigger on version tags (v1.0.0, v1.1.0, etc.)
  workflow_dispatch:  # Allow manual triggering

env:
  APP_NAME: "SunoReady"
  MAIN_SCRIPT: "run.py"
  PYTHON_VERSION: "3.11"

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      release_id: ${{ steps.create_release.outputs.id }}
    steps:
      - name: ğŸ“‹ Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: ğŸµ ${{ env.APP_NAME }} ${{ github.ref_name }}
          body: |            ## ğŸ‰ ${{ env.APP_NAME }} ${{ github.ref_name }}
            
            ### ğŸ“¥ Downloads:
            - **Windows**: `${{ env.APP_NAME }}-${{ github.ref_name }}-windows.exe`
            - **macOS**: `${{ env.APP_NAME }}-${{ github.ref_name }}-macos.dmg`
            - **Linux**: `${{ env.APP_NAME }}-${{ github.ref_name }}-linux.AppImage`
            
            ### âœ¨ Features:
            - ğŸµ High-performance audio processing for Suno AI
            - ï¿½ Copyright detection bypass capabilities
            - ï¿½ğŸ“º YouTube audio downloader with processing
            - ğŸ¨ Ultra-compact UI design
            - âš¡ Native C++ DLL acceleration (Windows)
            - ğŸŒ Cross-platform compatibility
            
            ### ğŸš€ Quick Start:
            1. Download the appropriate file for your OS
            2. Run the executable (no installation required)
            3. Process audio files for Suno AI upload
            4. Bypass copyright detection effortlessly!
            
            ### âš–ï¸ Legal Notice:
            This tool is for educational purposes. Users must comply with copyright laws.
            
            ---
            **Developer:** [Ilker Binzet](https://www.linkedin.com/in/binzet-me)  
            **Built with:** Python ${{ env.PYTHON_VERSION }} + PyInstaller + GitHub Actions
          draft: false
          prerelease: false

  build-windows:
    needs: create-release
    runs-on: windows-latest
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: ğŸ“¦ Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller      - name: ğŸ”§ Setup MinGW for DLL compilation
        run: |
          choco install mingw -y
          # Refresh environment
          $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")

      - name: ğŸ—ï¸ Compile DLL
        run: |
          cd build
          g++ -shared -static -fPIC -O3 -march=native -DNDEBUG sunoready_audio.cpp -o sunoready_audio.dll -static-libgcc -static-libstdc++ -lm
          if (Test-Path "sunoready_audio.dll") { 
            Write-Host "âœ… DLL compiled successfully" 
          } else { 
            Write-Host "âš ï¸ DLL compilation failed - will use Python fallback" 
          }
        continue-on-error: true  # Continue even if DLL compilation fails

      - name: ğŸ“‹ Create PyInstaller spec
        run: |
          $specContent = @"
          # -*- mode: python ; coding: utf-8 -*-
          import os
          from PyInstaller.utils.hooks import collect_data_files, collect_submodules

          # Collect all data files
          datas = []
          datas += collect_data_files('customtkinter')
          
          # Add config files
          datas += [('config', 'config')]
          
          # Add assets (fonts, icons)
          datas += [('assets', 'assets')]
          
          # Add DLL files if they exist
          if os.path.exists('build/sunoready_audio.dll'):
              datas += [('build/sunoready_audio.dll', 'build')]
          
          # Hidden imports for audio processing
          hiddenimports = [
              'customtkinter',
              'tkinter',
              'PIL',
              'librosa',
              'soundfile',
              'numpy',
              'scipy',
              'yt_dlp',
              'urllib3',
              'certifi',
              'charset_normalizer',
              'requests'
          ]

          # Collect submodules
          hiddenimports += collect_submodules('librosa')
          hiddenimports += collect_submodules('soundfile')
          hiddenimports += collect_submodules('yt_dlp')

          a = Analysis(
              ['${{ env.MAIN_SCRIPT }}'],
              pathex=[],
              binaries=[],
              datas=datas,
              hiddenimports=hiddenimports,
              hookspath=[],
              hooksconfig={},
              runtime_hooks=[],
              excludes=[
                  'matplotlib',
                  'PyQt5',
                  'PyQt6', 
                  'PySide2',
                  'PySide6',
                  'tkinter.test'
              ],
              win_no_prefer_redirects=False,
              win_private_assemblies=False,
              cipher=None,
              noarchive=False,
          )

          pyz = PYZ(a.pure, a.zipped_data, cipher=None)

          exe = EXE(
              pyz,
              a.scripts,
              a.binaries,
              a.zipfiles,
              a.datas,
              [],
              name='${{ env.APP_NAME }}',
              debug=False,
              bootloader_ignore_signals=False,
              strip=False,
              upx=True,
              upx_exclude=[],
              runtime_tmpdir=None,
              console=False,
              disable_windowed_traceback=False,
              argv_emulation=False,
              target_arch=None,
              codesign_identity=None,
              entitlements_file=None,
              icon='assets/generated-icon.png' if os.path.exists('assets/generated-icon.png') else None,
          )
          "@
          $specContent | Out-File -FilePath "${{ env.APP_NAME }}.spec" -Encoding UTF8

      - name: ğŸ”¨ Build Windows executable
        run: |
          pyinstaller --clean --noconfirm ${{ env.APP_NAME }}.spec

      - name: ğŸ“ Rename executable
        run: |
          $version = "${{ github.ref_name }}"
          $oldName = "dist/${{ env.APP_NAME }}.exe"
          $newName = "dist/${{ env.APP_NAME }}-$version-windows.exe"
          if (Test-Path $oldName) {
              Rename-Item $oldName $newName
              Write-Host "âœ… Renamed to: $newName"
          } else {
              Write-Host "âŒ File not found: $oldName"
              Get-ChildItem dist/
          }

      - name: ğŸ“¤ Upload Windows executable
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: ./dist/${{ env.APP_NAME }}-${{ github.ref_name }}-windows.exe
          asset_name: ${{ env.APP_NAME }}-${{ github.ref_name }}-windows.exe
          asset_content_type: application/octet-stream

  build-macos:
    needs: create-release
    runs-on: macos-latest
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: ğŸ“¦ Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller
          # Install additional macOS dependencies
          brew install portaudio ffmpeg

      - name: ğŸ“‹ Create PyInstaller spec for macOS
        run: |
          cat > ${{ env.APP_NAME }}.spec << 'EOF'
          # -*- mode: python ; coding: utf-8 -*-
          import os
          from PyInstaller.utils.hooks import collect_data_files, collect_submodules

          # Collect all data files
          datas = []
          datas += collect_data_files('customtkinter')
          
          # Add config files
          datas += [('config', 'config')]
          
          # Add assets (fonts, icons)
          datas += [('assets', 'assets')]
          
          # Hidden imports for audio processing
          hiddenimports = [
              'customtkinter',
              'tkinter',
              'PIL',
              'librosa',
              'soundfile',
              'numpy',
              'scipy',
              'yt_dlp',
              'urllib3',
              'certifi',
              'charset_normalizer',
              'requests'
          ]

          # Collect submodules
          hiddenimports += collect_submodules('librosa')
          hiddenimports += collect_submodules('soundfile')
          hiddenimports += collect_submodules('yt_dlp')

          a = Analysis(
              ['${{ env.MAIN_SCRIPT }}'],
              pathex=[],
              binaries=[],
              datas=datas,
              hiddenimports=hiddenimports,
              hookspath=[],
              hooksconfig={},
              runtime_hooks=[],
              excludes=[
                  'matplotlib',
                  'PyQt5',
                  'PyQt6', 
                  'PySide2',
                  'PySide6',
                  'tkinter.test'
              ],
              win_no_prefer_redirects=False,
              win_private_assemblies=False,
              cipher=None,
              noarchive=False,
          )

          pyz = PYZ(a.pure, a.zipped_data, cipher=None)

          exe = EXE(
              pyz,
              a.scripts,
              a.binaries,
              a.zipfiles,
              a.datas,
              [],
              name='${{ env.APP_NAME }}',
              debug=False,
              bootloader_ignore_signals=False,
              strip=False,
              upx=True,
              upx_exclude=[],
              runtime_tmpdir=None,
              console=False,
              disable_windowed_traceback=False,
              argv_emulation=False,
              target_arch=None,
              codesign_identity=None,
              entitlements_file=None,
          )

          app = BUNDLE(
              exe,
              name='${{ env.APP_NAME }}.app',
              icon='assets/generated-icon.png' if os.path.exists('assets/generated-icon.png') else None,
              bundle_identifier='com.sunoready.audioprocessor',
              info_plist={
                  'CFBundleDisplayName': '${{ env.APP_NAME }}',
                  'CFBundleVersion': '${{ github.ref_name }}',
                  'CFBundleShortVersionString': '${{ github.ref_name }}',
                  'NSHighResolutionCapable': True,
                  'NSMicrophoneUsageDescription': 'This app needs microphone access for audio processing',
              },
          )
          EOF

      - name: ğŸ”¨ Build macOS application
        run: |
          pyinstaller --clean --noconfirm ${{ env.APP_NAME }}.spec

      - name: ğŸ“¦ Create DMG
        run: |
          # Install create-dmg
          brew install create-dmg
          
          # Create DMG
          create-dmg \
            --volname "${{ env.APP_NAME }}" \
            --volicon "assets/generated-icon.png" \
            --window-pos 200 120 \
            --window-size 600 300 \
            --icon-size 100 \
            --icon "${{ env.APP_NAME }}.app" 175 120 \
            --hide-extension "${{ env.APP_NAME }}.app" \
            --app-drop-link 425 120 \
            "${{ env.APP_NAME }}-${{ github.ref_name }}-macos.dmg" \
            "dist/${{ env.APP_NAME }}.app"

      - name: ğŸ“¤ Upload macOS DMG
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: ./${{ env.APP_NAME }}-${{ github.ref_name }}-macos.dmg
          asset_name: ${{ env.APP_NAME }}-${{ github.ref_name }}-macos.dmg
          asset_content_type: application/octet-stream

  build-linux:
    needs: create-release
    runs-on: ubuntu-latest
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: ğŸ“¦ Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libasound2-dev \
            libportaudio2 \
            libsndfile1 \
            ffmpeg \
            build-essential \
            fuse

      - name: ğŸ“¦ Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller

      - name: ğŸ“‹ Create PyInstaller spec for Linux
        run: |
          cat > ${{ env.APP_NAME }}.spec << 'EOF'
          # -*- mode: python ; coding: utf-8 -*-
          import os
          from PyInstaller.utils.hooks import collect_data_files, collect_submodules

          # Collect all data files
          datas = []
          datas += collect_data_files('customtkinter')
          
          # Add config files
          datas += [('config', 'config')]
          
          # Add assets (fonts, icons)
          datas += [('assets', 'assets')]
          
          # Hidden imports for audio processing
          hiddenimports = [
              'customtkinter',
              'tkinter',
              'PIL',
              'librosa',
              'soundfile',
              'numpy',
              'scipy',
              'yt_dlp',
              'urllib3',
              'certifi',
              'charset_normalizer',
              'requests'
          ]

          # Collect submodules
          hiddenimports += collect_submodules('librosa')
          hiddenimports += collect_submodules('soundfile')
          hiddenimports += collect_submodules('yt_dlp')

          a = Analysis(
              ['${{ env.MAIN_SCRIPT }}'],
              pathex=[],
              binaries=[],
              datas=datas,
              hiddenimports=hiddenimports,
              hookspath=[],
              hooksconfig={},
              runtime_hooks=[],
              excludes=[
                  'matplotlib',
                  'PyQt5',
                  'PyQt6', 
                  'PySide2',
                  'PySide6',
                  'tkinter.test'
              ],
              win_no_prefer_redirects=False,
              win_private_assemblies=False,
              cipher=None,
              noarchive=False,
          )

          pyz = PYZ(a.pure, a.zipped_data, cipher=None)

          exe = EXE(
              pyz,
              a.scripts,
              a.binaries,
              a.zipfiles,
              a.datas,
              [],
              name='${{ env.APP_NAME }}',
              debug=False,
              bootloader_ignore_signals=False,
              strip=False,
              upx=True,
              upx_exclude=[],
              runtime_tmpdir=None,
              console=False,
              disable_windowed_traceback=False,
              argv_emulation=False,
              target_arch=None,
              codesign_identity=None,
              entitlements_file=None,
          )
          EOF

      - name: ğŸ”¨ Build Linux executable
        run: |
          pyinstaller --clean --noconfirm ${{ env.APP_NAME }}.spec

      - name: ğŸ“¦ Create AppImage
        run: |
          # Download AppImageTool
          wget -O appimagetool-x86_64.AppImage https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage
          chmod +x appimagetool-x86_64.AppImage
          
          # Create AppDir structure
          mkdir -p AppDir/usr/bin
          mkdir -p AppDir/usr/share/applications
          mkdir -p AppDir/usr/share/icons/hicolor/256x256/apps
          
          # Copy executable
          cp dist/${{ env.APP_NAME }} AppDir/usr/bin/
          
          # Create desktop file
          cat > AppDir/usr/share/applications/${{ env.APP_NAME }}.desktop << EOF
          [Desktop Entry]
          Type=Application
          Name=${{ env.APP_NAME }}
          Exec=${{ env.APP_NAME }}
          Icon=${{ env.APP_NAME }}
          Comment=High-performance audio processing tool
          Categories=AudioVideo;Audio;
          Terminal=false
          EOF
          
          # Copy icon (if exists)
          if [ -f "assets/generated-icon.png" ]; then
            cp assets/generated-icon.png AppDir/usr/share/icons/hicolor/256x256/apps/${{ env.APP_NAME }}.png
            cp assets/generated-icon.png AppDir/${{ env.APP_NAME }}.png
          fi
          
          # Create AppRun
          cat > AppDir/AppRun << 'EOF'
          #!/bin/bash
          cd "$(dirname "$0")"
          exec ./usr/bin/${{ env.APP_NAME }} "$@"
          EOF
          chmod +x AppDir/AppRun
          
          # Create AppImage
          ./appimagetool-x86_64.AppImage AppDir ${{ env.APP_NAME }}-${{ github.ref_name }}-linux.AppImage

      - name: ğŸ“¤ Upload Linux AppImage
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: ./${{ env.APP_NAME }}-${{ github.ref_name }}-linux.AppImage
          asset_name: ${{ env.APP_NAME }}-${{ github.ref_name }}-linux.AppImage
          asset_content_type: application/octet-stream

  update-readme:
    needs: [create-release, build-windows, build-macos, build-linux]
    runs-on: ubuntu-latest
    if: always() && (needs.build-windows.result == 'success' || needs.build-macos.result == 'success' || needs.build-linux.result == 'success')
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ“ Update README with latest release info
        run: |
          VERSION="${{ github.ref_name }}"
          
          # Create download links section
          cat > download_section.md << EOF
          
          ## ğŸ“¥ Latest Release: $VERSION
          
          ### Quick Download:
          - **ğŸªŸ Windows**: [Download ${{ env.APP_NAME }}-$VERSION-windows.exe](https://github.com/${{ github.repository }}/releases/download/$VERSION/${{ env.APP_NAME }}-$VERSION-windows.exe)
          - **ğŸ macOS**: [Download ${{ env.APP_NAME }}-$VERSION-macos.dmg](https://github.com/${{ github.repository }}/releases/download/$VERSION/${{ env.APP_NAME }}-$VERSION-macos.dmg)  
          - **ğŸ§ Linux**: [Download ${{ env.APP_NAME }}-$VERSION-linux.AppImage](https://github.com/${{ github.repository }}/releases/download/$VERSION/${{ env.APP_NAME }}-$VERSION-linux.AppImage)
          
          > **ğŸ“± No installation required!** Just download and run.
          
          [ğŸ“‹ View All Releases](https://github.com/${{ github.repository }}/releases) | [ğŸ› Report Issues](https://github.com/${{ github.repository }}/issues)
          
          ---
          EOF
          
          # Update README.md
          if grep -q "## ğŸ“¥ Latest Release:" README.md; then
            # Replace existing download section
            sed -i '/## ğŸ“¥ Latest Release:/,/^---$/d' README.md
          fi
          
          # Add new download section after title
          sed -i '1r download_section.md' README.md
          
          # Clean up
          rm download_section.md

      - name: ğŸ’¾ Commit README changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add README.md
          git diff --staged --quiet || git commit -m "ğŸ“ Update README with release ${{ github.ref_name }} download links"
          git push
        continue-on-error: true  # Don't fail if no changes or permission issues
